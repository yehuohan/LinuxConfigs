
#===============================================================================
# qt project
#===============================================================================
snippet qmain "qt main function fot gui"
#include "${1:mainwindow}.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    ${2:MainWindow} w;
    w.show();

    return a.exec();
}
endsnippet

snippet qmainc "qt main function for console"
#include <QCoreApplication>

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    return a.exec();
}
endsnippet

snippet qwin "qt inherit QMainWindow class"
#include <QMainWindow>

class ${1:MainWindow} : public QMainWindow
{
    Q_OBJECT
public:
    explicit $1(QWidget *parent = Q_NULLPTR):QMainWindow(parent) {}
    ~$1() {}

signals:

public slots:
};
endsnippet

snippet qwinui "qt gui with ui file"
#include <QMainWindow>
#include "ui_${2:mainwindow}.h"

namespace Ui {
class $1;
}

class ${1:MainWindow} : public QMainWindow
{
    Q_OBJECT
public:
    explicit $1(QWidget *parent = Q_NULLPTR);
    ~$1();

private:
    Ui::$1* ui;
};

$1::$1(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::$1)
{
    ui->setupUi(this);
}
endsnippet

snippet qobj "qt inherit Obeject class"
#include <QObject>

class ${1:Object} : public QObject
{
    Q_OBJECT
public:
    explicit $1(QObject *parent = Q_NULLPTR):QObject(parent) {}
    ~$1() {}

signals:

public slots:
};
endsnippet


#===============================================================================
# algorithm for c/c++
#===============================================================================
snippet aquick-sort "quick sort in c/c++"
int partition(int* pdata, int lo, int hi)
{
    int pivot = pdata[lo];
    while(lo < hi)
    {
        while(lo < hi && pdata[hi] >= pivot) hi--;
        pdata[lo] = pdata[hi];
        while(lo < hi && pdata[lo] <= pivot) lo++;
        pdata[hi] = pdata[lo];
    }
    pdata[lo] = pivot;
    return lo;
}
void quick_sort(int* pdata, int lo, int hi)
{
    if (hi - lo < 2)
        return;
    int mi = partition(pdata, lo, hi-1);
    quick_sort(pdata, lo, mi);
    quick_sort(pdata, mi + 1, hi);
}
endsnippet

snippet ainsert-sort "insertion sort in c/c++"
void insertion_sort(int* pdata, int lo, int hi)
{
    for (int k = lo + 1; k < hi; k ++)
    {
        int n = k;
        int tmp = pdata[n];
        while (n > lo && tmp < pdata[n-1])
        {
            pdata[n] = pdata[n-1];
            n--;
        }
        pdata[n] = tmp;
    }
}
endsnippet

snippet apre-order "pre-order sort in c/c++"
typedef struct node_s
{
    int data;
    struct node_s* parent;
    struct node_s* left;
    struct node_s* right;
}node_t;
void traverse_preorder(node_t* root, void (*visit)(node_t*))
{
    node_t* d = root;
    std::stack<node_t*> s;
    s.push(d);
    while (!s.empty())
    {
        d = s.top(); s.pop();
        while (d)
        {
            visit(d);
            s.push(d->right);
            d = d->left;
        }
    }
}
endsnippet

snippet ain-order "in-order sort in c/c++"
typedef struct node_s
{
    int data;
    struct node_s* parent;
    struct node_s* left;
    struct node_s* right;
}node_t;
void traverse_inorder(node_t* root, void (*visit)(node_t*))
{
    node_t* d = root;
    std::stack<node_t*> s;
    while (true)
    {
        while (d)
        {
            s.push(d);
            d = d->left;
        }
        if (s.empty()) break;
        else
        {
            d = s.top(); s.pop();
            visit(d);
            d = d->right;
        }
    }
}
endsnippet

snippet apost-order "post-order sort in c/c++"
typedef struct node_s
{
    int data;
    struct node_s* parent;
    struct node_s* left;
    struct node_s* right;
}node_t;
void traverse_postorder(node_t* root, void (*visit)(node_t*))
{
    node_t* d = root;
    node_t* last = nullptr;
    std::stack<node_t*> s;
    while (true)
    {
        while (d)
        {
            s.push(d);
            d = d->left;
        }
        while (!s.empty())
        {
            d = s.top(); s.pop();
            if (!d->right || last == d->right)
            {
                visit(d);
                last = d;
            }
            else
            {
                s.push(d);
                d = d->right;
                break;
            }
        }
        if (s.empty()) break;
    }
}
endsnippet

snippet alayer-order "layer-order sort in c/c++"
typedef struct node_s
{
    int data;
    struct node_s* parent;
    struct node_s* left;
    struct node_s* right;
}node_t;
void traverse_layerorder(node_t* root, void (*visit)(node_t*))
{
    node_t* d = root;
    std::queue<node_t*> q;
    q.push(d);
    while (!q.empty())
    {
        d = q.front(); q.pop();
        visit(d);
        if (d->left) q.push(d->left);
        if (d->right) q.push(d->right);
    }
}
endsnippet


#===============================================================================
# doxygen style for c/c++
#===============================================================================
snippet dmpage "doxygen c/c++ mainpage"
//==============================================================================
/*!
 * @mainpage ${1:title}
#${0:markdown}
 */
//==============================================================================
endsnippet

snippet dpage "doxygen c/c++ page"
//==============================================================================
/*!
 * @page ${1:name} ${2:title}
${0:markdown}
 */
//==============================================================================
endsnippet

snippet dspage "doxygen c/c++ subpage"
 * @subpage ${1:name} "${2:text}"
endsnippet

snippet dfile "doxygen c/c++ file"
//==============================================================================
/*!
 * @file ${0}
 * @brief
 *
 * @date `!v strftime("%Y-%m-%d")`
 * @version
 * @author
 * @copyright
 */
//==============================================================================
endsnippet

snippet dbrief "doxygen c/c++ brief for class etc."
/*!
 * @brief ${0}
 *
 */
endsnippet

snippet dfunc "doxygen c/c++ function"
/*!
 * @brief ${0}
 *
 * @param None
 * @return
 * @retval None
 */
endsnippet

snippet dmod "doxygen c/c++ module define"
/*!
 * @defgroup ${1:label} ${2:name}
 *${0}
 * @{
 * @}
 */
endsnippet

snippet dmod1 "doxygen c/c++ module"
/*!
 * @defgroup ${1:label} ${2:name}
 *${0}
 * @{
 */

/*! @} */
endsnippet

snippet damod "doxygen c/c++ addtomodule"
/*!
 * @addtogroup ${1:label}
 *${0}
 * @{
 */

/*! @} */
endsnippet

snippet dblock "doxygen c/c++ block"
/*!
 * @name ${0}
 * @{
 */

/*! @} */
endsnippet

snippet dline "doxygen c/c++ line"
/** ${0} */
endsnippet

snippet dlline "doxygen c/c++ last-line"
/**< ${0} */
endsnippet

